
Import "calculator_definition".


Set debug on.


Theorem fun__contains__member : forall E N,
   member N E -> is_list is_string E -> fun__contains N E true.
induction on 1. intros. case H1.
  %Subgoal 1
   search.
  %Subgoal 2
   case H2. apply IH to H3 H5. apply is_list_member to H5 H3.
   apply is_string_eq_or_not to H7 H4. case H8.
     %Subgoal 2.2
      search.
     %Subgoal 2.3
      search.

Theorem fun__contains__to__member : forall E N,
   fun__contains N E true -> member N E.
induction on 1. intros. case H1.
  %contains here
   search.
  %contains later
   apply IH to H3. search.

Theorem fun__contains__total : forall E N,
  is_list is_string E -> is_string N -> exists B, fun__contains N E B.
induction on 1. intros. case H1 (keep).
  %Subgoal 1
   exists false. search.
  %Subgoal 2
   apply is_string_eq_or_not to H2 H3. case H5.
     %Subgoal 2.1
      search.
     %Subgoal 2.2
      apply IH to H4 H2. search.

Theorem fun__lookup__member : forall E V N,
  is_list (is_pair is_string is_integer) E -> member (N, V) E ->
  exists V', fun__lookup E N V'.
induction on 2. intros. case H2.
  %member here
   search.
  %member later
   case H1. apply IH to H5 H3. case H4. apply is_list_member to H5 H3.
   case H9. apply is_string_eq_or_not to H7 H10. case H12.
     %equal
      exists B1. search.
     %not equal
      exists V'. search.

Theorem fun__lookup__unique : forall E V N N',
  fun__lookup E V N -> fun__lookup E V N' -> N = N'.
induction on 1. intros. case H1.
  %lookup 1 here
   case H2.
     %lookup 2 here
      search.
     %lookup 2 later
      assert V = V. apply H3 to H5.
  %lookup 1 later
   case H2.
     %lookup 2 here
      assert V = V. apply H3 to H5.
     %lookup 2 later
      apply IH to H4 H6. search.





Set subgoals off.
Set debug off.


Extensible_Theorem value_nonexistence_unique__Expr :
  forall T1 T2 Env,
    T1 = T2 ->
    T1.env = Env -> T2.env = Env ->
    T1.value = < no value > ->
    T2.value = < no value >
on T1.
split.
%intConst
 intros Structure N_Is Eq. case T1.value.
%plus
 intros IH1 IH2 Structure Eq. case_structure T2 in Eq with Structure.
 case T1.value.
   %E.value does not exist
    case E.env. case E2.env. apply symmetry to H10.
    apply IH1 to _ H23 H18 H21 H16. case T2.value. search.
   %E1.value does not exist
    case E1.env. case E3.env. apply symmetry to H11.
    apply IH2 to _ H24 H20 H23 H17. case T2.value. search. search.
%minus
 intros IH1 IH2 Structure Eq. case_structure T2 in Eq with Structure.
 case T1.value.
   %E.value does not exist
    case E.env. case E2.env. apply symmetry to H10.
    apply IH1 to _ H23 H18 H21 H16. case T2.value. search.
   %E1.value does not exist
    case E1.env. case E3.env. apply symmetry to H11.
    apply IH2 to _ H24 H20 H23 H17. case T2.value. search. search.
%mult
 intros IH1 IH2 Structure Eq. case_structure T2 in Eq with Structure.
 case T1.value.
   %E.value does not exist
    case E.env. case E2.env. apply symmetry to H10.
    apply IH1 to _ H23 H18 H21 H16. case T2.value. search.
   %E1.value does not exist
    case E1.env. case E3.env. apply symmetry to H11.
    apply IH2 to _ H24 H20 H23 H17. case T2.value. search. search.
%letBind
 intros IH1 IH2 Structure L_Is Eq.
 case_structure T2 in Eq with Structure. clear H13.
 apply symmetry to H10. apply symmetry to H16. clear H10. clear H16.
 case T1.value. skip.
%name
 intros Structure L_Is Eq. case_structure T2 in Eq with Structure.
 case T1.value. case T2.value.
   %fun__lookup doesn't return for T2
    search.
   %fun__lookup returns for T2
    assert exists Ret, fun__lookup Env2 L Ret. apply H12 to H16.


Extensible_Theorem value_unique__Expr :
  forall T1 T2 Env V1 V2,
    T1 = T2 ->
    T1.env = Env -> T2.env = Env ->
    T1.value = V1 -> T2.value = V2 ->
    V1 = V2
on T1.
split.
%intConst
 intros Structure N_Is Eq. case T1.value.
 case_structure T2 in Eq with Structure. case T2.value. search.
%plus
 intros IH1 IH2 Structure Eq. case_structure T2 in Eq with Structure.
 case E.env. case E2.env. rename Val1 to Env. case T1.value.
 case T2.value. apply symmetry to H11. apply symmetry to H12.
 apply IH1 to _ H30 H17 H20 H23 H27. apply IH2 to _ H31 H18 H21 H24 H28.
 apply plus_integer_unique to H25 H29. search.
%minus
 intros IH1 IH2 Structure Eq. case_structure T2 in Eq with Structure.
 case E.env. case E2.env. rename Val1 to Env. case T1.value.
 case T2.value. apply symmetry to H11. apply symmetry to H12.
 apply IH1 to _ H30 H17 H20 H23 H27. apply IH2 to _ H31 H18 H21 H24 H28.
 apply minus_integer_unique to H25 H29. search.
%mult
 intros IH1 IH2 Structure Eq. case_structure T2 in Eq with Structure.
 case E.env. case E2.env. rename Val1 to Env. case T1.value.
 case T2.value. apply symmetry to H11. apply symmetry to H12.
 apply IH1 to _ H30 H17 H20 H23 H27. apply IH2 to _ H31 H18 H21 H24 H28.
 apply multiply_integer_unique to H25 H29. search.
%letBind
 intros IH1 IH2 Structure L_Is Eq. case_structure T2 in Eq with Structure.
 case E.env.
   %E.value does not exist
    skip.
   %E.value does exist
    case E2.env.
      %E2.value does not exist
       skip.
      %E2.value does exist
       Eq1 : apply symmetry to H11. Eq2 : apply symmetry to H12.
       case T1.value. case T2.value.
       apply IH1 to _ Eq1 H18 H23 H19 H24.
       apply append_unique to H20 H25.
       apply IH2 to _ Eq2 H21 H26 H28 H30. search.
%name
 intros Structure L_Is Eq. case_structure T2 in Eq with Structure.
 case T1.value. case T2.value. apply fun__lookup__unique to H13 H16.
 search.


Extensible_Theorem value_unique__Root :
  forall R1 R2 V1 V2,
    R1 = R2 ->
    R1.value = V1 -> R2.value = V2 ->
    V1 = V2
on R1.




Extensible_Theorem valExists__implies__value__Expr :
   forall T KNames Env,
      T.knownNames = KNames -> T.env = Env ->
      (forall Name, member Name KNames ->
          exists Val, member (Name, Val) Env) ->
      T.valExists = true -> exists V, T.value = V
on T.
split.
%intConst
 intros Structure. case T.value. exists N. search.
%plus
 intros IH1 IH2 Structure. case E.knownNames. case E.env.
 case T.valExists. apply IH1 to H10 H13 H7 H16.
 apply IH2 to H11 H14 H7 H17. case T.value. search.
%minus
 intros IH1 IH2 Structure. case E.knownNames. case E.env.
 case T.valExists. apply IH1 to H10 H13 H7 H16.
 apply IH2 to H11 H14 H7 H17. case T.value. search.
%mult
 intros IH1 IH2 Structure. case E.knownNames. case E.env.
 case T.valExists. apply IH1 to H10 H13 H7 H16.
 apply IH2 to H11 H14 H7 H17. case T.value. search.
%letBind
 intros IH1 IH2 Structure. case E.knownNames. case H12. case H14.
 case T.valExists. case T.value.
   %T.value does not exist because E1.value does not exist
    case E.env.
      %E1.env does not exist because E.value = <no value>
       apply IH1 to H11 H21 H8 H16.
      %env exists
       case H23. case H25. apply IH2 to H13 H24 _ H17.
         %IH2 relate knownNames and env
          intros Mem. case Mem.
            %member first
             exists EVal. search.
            %member rest
             apply H8 to H26. exists Val1. search.
   %T.value exists
    search.
%name
 intros Structure. case T.valExists.
 apply fun__contains__to__member to H10. apply H6 to H11.
 apply attr_is to H5. apply fun__lookup__member to H13 H12.
 case T.value.
   %T.value = <no value> because lookup does not return
    assert exists Ret, fun__lookup Env1 L Ret. apply H17 to H18.
   %T.value exists
    search.


Extensible_Theorem valExists__implies__value__Root :
  forall (R : nt_Root),
     R.valExists = true -> exists V, R.value = V
on R.
%root
 intros Structure. case R.valExists. case E.knownNames. case E.env.
 apply valExists__implies__value__Expr to _ H7 H8 _ H6.
   %member assumption for Expr theorem
    intros Mem. case Mem.
 case R.value. search.






%If knownNames exists, so does valExists
Extensible_Theorem knownNames__implies__valExists__Expr :
  forall T KnownNames,
     T.knownNames = KnownNames ->
     exists B, T.valExists = B
on T.
split.
%intConst
 intros Structure. case T.valExists. search.
%plus
 intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
   %T.valExists = E.valExists = <no value>
    apply IH1 to H7.
   %T.valExists = E1.valExists = <no value>
    apply IH2 to H8.
   %T.valExists = E1.valExists
    exists Val1. search.
   %T.valExists = false
    exists false. search.
%minus
 intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
   %T.valExists = E.valExists = <no value>
    apply IH1 to H7.
   %T.valExists = E1.valExists = <no value>
    apply IH2 to H8.
   %T.valExists = E1.valExists
    exists Val1. search.
   %T.valExists = false
    exists false. search.
%mult
 intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
   %T.valExists = E.valExists = <no value>
    apply IH1 to H7.
   %T.valExists = E1.valExists = <no value>
    apply IH2 to H8.
   %T.valExists = E1.valExists
    exists Val1. search.
   %T.valExists = false
    exists false. search.
%letBind
 intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
   %T.valExists = E.valExists = <no value>
    apply IH1 to H8.
   %T.valExists = E1.valExists = <no value>
    apply IH2 to H10.
   %T.valExists = E1.valExists
    exists Val. search.
   %T.valExists = false
    exists false. search.
%name
 intros Structure. case T.valExists.
   %contains does not return
    apply attr_is to H6. apply fun__contains__total to H8 H2.
    assert (exists B, fun__contains L KnownNames1 B).
    apply H7 to H10.
   %contains returns a value
    exists Val. search.


Extensible_Theorem valExists__Root : forall (R : nt_Root),
  exists B, R.valExists = B
on R.
%root
 intros Structure. case R.valExists.
   %T.valExists = E.valExists = <no value>
    case E.knownNames.
    apply knownNames__implies__valExists__Expr to _ H6.
   %T.valExists has a value
    exists Val. search.








