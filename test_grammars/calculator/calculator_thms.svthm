
Import "calculator_definition".


Set debug on.


Theorem fun__contains__member : forall E N,
   member N E -> is_list is_string E -> fun__contains N E true.
induction on 1. intros. case H1.
  %Subgoal 1
   search.
  %Subgoal 2
   case H2. apply IH to H3 H5. apply is_list_member to H5 H3.
   apply is_string_eq_or_not to H7 H4. case H8.
     %Subgoal 2.2
      search.
     %Subgoal 2.3
      search.

Theorem fun__contains__to__member : forall E N,
   fun__contains N E true -> member N E.
induction on 1. intros. case H1.
  %contains here
   search.
  %contains later
   apply IH to H3. search.

Theorem fun__contains__total : forall E N,
  is_list is_string E -> is_string N -> exists B, fun__contains N E B.
induction on 1. intros. case H1 (keep).
  %Subgoal 1
   exists false. search.
  %Subgoal 2
   apply is_string_eq_or_not to H2 H3. case H5.
     %Subgoal 2.1
      search.
     %Subgoal 2.2
      apply IH to H4 H2. search.

Theorem fun__lookup__member : forall E V N,
  is_list (is_pair is_string is_integer) E -> member (N, V) E ->
  exists V', fun__lookup E N V'.
induction on 2. intros. case H2.
  %member here
   search.
  %member later
   case H1. apply IH to H5 H3. case H4. apply is_list_member to H5 H3.
   case H9. apply is_string_eq_or_not to H7 H10. case H12.
     %equal
      exists B1. search.
     %not equal
      exists V'. search.





Set subgoals off.
Set debug off.


Extensible_Theorem valExists__implies__value__Expr :
   forall T KNames Env,
      T.knownNames = KNames -> T.env = Env ->
      (forall Name, member Name KNames ->
          exists Val, member (Name, Val) Env) ->
      T.valExists = true -> exists V, T.value = V
on T.
split.
  %intConst
   intros Structure. case T.value. exists N. search.
  %plus
   intros IH1 IH2 Structure. case E.knownNames. case E.env.
   case T.valExists. apply IH1 to _ H10 H13 H7 H16.
   apply IH2 to _ H11 H14 H7 H17. case T.value. search.
  %minus
   intros IH1 IH2 Structure. case E.knownNames. case E.env.
   case T.valExists. apply IH1 to _ H10 H13 H7 H16.
   apply IH2 to _ H11 H14 H7 H17. case T.value. search.
  %mult
   intros IH1 IH2 Structure. case E.knownNames. case E.env.
   case T.valExists. apply IH1 to _ H10 H13 H7 H16.
   apply IH2 to _ H11 H14 H7 H17. case T.value. search.
  %letBind
   intros IH1 IH2 Structure. case E.knownNames. case H12. case H14.
   case T.valExists. case T.value.
     %T.value does not exist because E1.value does not exist
      case E.env.
        %E1.env does not exist because E.value = <no value>
         apply IH1 to _ H11 H21 H8 H16.
        %env exists
         case H23. case H25. apply IH2 to _ H13 H24 _ H17.
           %IH2 relate knownNames and env
            intros Mem. case Mem.
              %member first
               exists EVal. search.
              %member rest
               apply H8 to H26. exists Val1. search.
     %T.value exists
      search.
  %name
   intros Structure. case T.valExists.
   apply fun__contains__to__member to H10. apply H6 to H11.
   apply attr_is to H5. apply fun__lookup__member to H13 H12.
   case T.value.
     %T.value = <no value> because lookup does not return
      assert exists Ret, fun__lookup Env1 L Ret. apply H17 to H18.
     %T.value exists
      search.


Extensible_Theorem valExists__implies__value__Root :
  forall (R : nt_Root),
     R.valExists = true -> exists V, R.value = V
on R.
%root
 intros Structure. case R.valExists. case E.knownNames. case E.env.
 apply valExists__implies__value__Expr to _ H7 H8 _ H6.
   %member assumption for Expr theorem
    intros Mem. case Mem.
 case R.value. search.






%If knownNames exists, so does valExists
Extensible_Theorem knownNames__implies__valExists__Expr :
  forall T KnownNames,
     T.knownNames = KnownNames ->
     exists B, T.valExists = B
on T.
split.
   %intConst
    intros Structure. case T.valExists. search.
   %plus
    intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
      %T.valExists = E.valExists = <no value>
       apply IH1 to _ H7.
      %T.valExists = E1.valExists = <no value>
       apply IH2 to _ H8.
      %T.valExists = E1.valExists
       exists Val1. search.
      %T.valExists = false
       exists false. search.
   %minus
    intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
      %T.valExists = E.valExists = <no value>
       apply IH1 to _ H7.
      %T.valExists = E1.valExists = <no value>
       apply IH2 to _ H8.
      %T.valExists = E1.valExists
       exists Val1. search.
      %T.valExists = false
       exists false. search.
   %mult
    intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
      %T.valExists = E.valExists = <no value>
       apply IH1 to _ H7.
      %T.valExists = E1.valExists = <no value>
       apply IH2 to _ H8.
      %T.valExists = E1.valExists
       exists Val1. search.
      %T.valExists = false
       exists false. search.
   %letBind
    intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
      %T.valExists = E.valExists = <no value>
       apply IH1 to _ H8.
      %T.valExists = E1.valExists = <no value>
       apply IH2 to _ H10.
      %T.valExists = E1.valExists
       exists Val. search.
      %T.valExists = false
       exists false. search.
   %name
    intros Structure. case T.valExists.
      %contains does not return
       apply attr_is to H6. apply fun__contains__total to H8 H2.
       assert (exists B, fun__contains L KnownNames1 B).
       apply H7 to H10.
      %contains returns a value
       exists Val. search.


Extensible_Theorem valExists__Root : forall (R : nt_Root),
  exists B, R.valExists = B
on R.
%root
 intros Structure. case R.valExists.
   %T.valExists = E.valExists = <no value>
    case E.knownNames.
    apply knownNames__implies__valExists__Expr to _ H6.
   %T.valExists has a value
    exists Val. search.


