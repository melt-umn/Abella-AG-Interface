
Import "calculator_definition".


Set debug off.


Theorem contains__member : forall E N,
   member N E -> is_list is_string E -> contains(N, E) = true.
induction on 1. intros. case H1.
  %Subgoal 1
   search.
  %Subgoal 2
   case H2. apply IH to H3 H5. apply is_list_member to H5 H3.
   apply is_string_eq_or_not to H7 H4. case H8.
     %Subgoal 2.2
      search.
     %Subgoal 2.3
      assert null(B::L) = false. assert head(B::L) = B.
      assert B = N -> false. search. search.

Theorem contains__to__member : forall E N,
   contains(N, E) = true -> member N E.
induction on 1. intros. case H1.
  %contains here
   case H2. case H3. search.
  %contains later
   apply IH to H6. case H5. case H3. search.

Theorem contains__total : forall E N,
  is_list is_string E -> is_string N -> exists B, contains(N, E) = B.
induction on 1. intros. case H1 (keep).
  %Subgoal 1
   exists false. search.
  %Subgoal 2
   apply is_string_eq_or_not to H2 H3. case H5.
     %Subgoal 2.1
      search.
     %Subgoal 2.2
      apply IH to H4 H2. exists B. assert null(H::T) = false.
      assert head(H::T) = false. assert H = N -> false. search.
      search.

Theorem lookup__member : forall E V N,
  is_list (is_pair is_string is_integer) E -> member (N, V) E ->
  exists V', lookup(E, N) = V'.
induction on 2. intros. case H2.
  %member here
   search.
  %member later
   case H1. apply IH to H5 H3. case H4. apply is_list_member to H5 H3.
   case H9. apply is_string_eq_or_not to H7 H10. case H12.
     %equal
      exists B1. search.
     %not equal
      exists V'. search.

Theorem lookup__unique : forall E V N N',
  lookup(E, V) = N -> lookup(E, V) = N' -> N = N'.
induction on 1. intros. case H1.
  %lookup 1 here
   case H3. case H5. case H4. case H6. case H2.
     %lookup 2 here
      case H7. case H9. case H10. search.
     %lookup 2 later
      case H7. case H8. F: assert false. backchain H9. case F.
  %lookup 1 later
   case H3. case H4. case H6. case H2.
     %lookup 2 here
      F: assert false. case H8. case H9. backchain H5. case F.
     %lookup 2 later
      case H8. case H9. case H11. apply IH to H7 H12. search.





Set subgoals off.

/*
  Why do we have so many mutual theorems here?  Because we defined the
  value equation for letBind as having a value regardless of the
  existence of values for the environment or the value for expression
  E1 (in <let x = E1 in E2>), we need to consider the cases where they
  might not exist, which leads to a lot of theorems we wouldn't
  normally need to consider.
*/
Extensible_Theorem value_unique_lemmas__Expr :
  (forall T1 T2,
     T1 = T2 ->
     T1.env = <no value> -> T2.env = <no value> ->
     T1.value = <no value> ->
     T2.value = <no value>) /\
  (forall T1 T2 V,
     T1 = T2 ->
     T1.env = <no value> -> T2.env = <no value> ->
     T1.value = V ->
     T2.value = V) /\
  (forall T1 T2 Env,
     T1 = T2 ->
     T1.env = Env -> T2.env = Env ->
     T1.value = <no value> ->
     T2.value = <no value>) /\
  (forall T1 T2 Env V,
     T1 = T2 ->
     T1.env = Env -> T2.env = Env ->
     T1.value = V ->
     T2.value = V)
on T1 T1 T1 T1.
split.
%No Environment, No Value
 %intConst
  intros Structure N_Is Eq T1Env T2Env T1Val. case T1.value.
 %plus
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8. clear H7 H8.
  case E.env. case E2.env. case T1.value.
    %E.value does not exist
     apply IH1_NE_NV to Eq1 H14 H17 H19. case T2.value. search.
    %E1.value does not exist
     apply IH2_NE_NV to Eq2 _ _ _. case T2.value. search. search.
 %minus
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8. clear H7 H8.
  case E.env. case E2.env. case T1.value.
    %E.value does not exist
     apply IH1_NE_NV to Eq1 H14 H17 H19. case T2.value. search.
    %E1.value does not exist
     apply IH2_NE_NV to Eq2 _ _ _. case T2.value. search. search.
 %mult
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8. clear H7 H8.
  case E.env. case E2.env. case T1.value.
    %E.value does not exist
     apply IH1_NE_NV to Eq1 H14 H17 H19. case T2.value. search.
    %E1.value does not exist
     apply IH2_NE_NV to Eq2 _ _ _. case T2.value. search. search.
 %letBind
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure L_Is Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  Eq2 : apply symmetry to H8. clear H8.
  case E1.env.
    %
     case E3.env.
       %
        case T1.value. apply IH2_NE_NV to Eq2 H13 H17 H22.
        case T2.value. search.
       %
        case T1.value. apply IH2_NE_NV to Eq2 _ _ _.
        case T2.value. search.
    %
     case E3.env.
       %
        case T1.value. apply IH2_NE_NV to Eq2 _ _ _.
        case T2.value. search.
       %
        case T1.value. apply IH2_NE_NV to Eq2 _ _ _.
        case T2.value. search.
 %name
  intros Structure L_Is Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  case T2.value. search.
%No Environment, Value Exists
 %intConst
  intros Structure N_Is Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  case T1.value. case T2.value. search.
 %plus
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8. clear H7 H8.
  case E.env. case E2.env. case T1.value.
  apply IH1_NE_V to Eq1 _ _ _. apply IH2_NE_V to Eq2 _ _ _.
  case T2.value. apply plus_integer_unique to H21 H27. search.
 %minus
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8. clear H7 H8.
  case E.env. case E2.env. case T1.value.
  apply IH1_NE_V to Eq1 _ _ _. apply IH2_NE_V to Eq2 _ _ _.
  case T2.value. apply minus_integer_unique to H21 H27. search.
 %mult
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8. clear H7 H8.
  case E.env. case E2.env. case T1.value.
  apply IH1_NE_V to Eq1 _ _ _. apply IH2_NE_V to Eq2 _ _ _.
  case T2.value. apply multiply_integer_unique to H21 H27. search.
 %letBind
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV
         IH2_NV IH1_V IH2_V Structure L_Is Eq T1Env T2Env T1Val.
  case_structure T2 in Eq with Structure.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8. clear H7 H8.
  case E.env.
    %
     case E2.env.
       %
        case T1.value. apply IH2_NE_V to Eq2 _ _ _. case T2.value.
        search.
      %
       case T1.value. apply IH2_NE_V to Eq2 _ _ _. case T2.value.
       search.
    %
     case E2.env.
       %
        case T1.value. apply IH2_NE_V to Eq2 _ _ _. case T2.value.
        search.
      %
       case T1.value. apply IH2_NE_V to Eq2 _ _ _. case T2.value.
       search.
 %name
  intros Structure L_Is Eq T1Env T2Env T1Val. case T1.value.
%No Value
 %intConst
  intros Structure N_Is Eq. case T1.value.
 %plus
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V
         IH1_NV IH2_NV IH1_V IH2_V Structure Eq.
  case_structure T2 in Eq with Structure.
  case T1.value.
    %E.value does not exist
     case E.env. case E2.env. apply symmetry to H10.
     apply IH1_NV to H23 _ _ _. case T2.value. search.
    %E1.value does not exist
     case E1.env. case E3.env. apply symmetry to H11.
     apply IH2_NV to H24 _ _ _. case T2.value. search. search.
 %minus
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V
         IH1_NV IH2_NV IH1_V IH2_V Structure Eq.
  case_structure T2 in Eq with Structure.
  case T1.value.
    %E.value does not exist
     case E.env. case E2.env. apply symmetry to H10.
     apply IH1_NV to H23 _ _ _. case T2.value. search.
    %E1.value does not exist
     case E1.env. case E3.env. apply symmetry to H11.
     apply IH2_NV to H24 _ _ _. case T2.value. search. search.
 %mult
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V
         IH1_NV IH2_NV IH1_V IH2_V Structure Eq.
  case_structure T2 in Eq with Structure.
  case T1.value.
    %E.value does not exist
     case E.env. case E2.env. apply symmetry to H10.
     apply IH1_NV to H23 _ _ _. case T2.value. search.
    %E1.value does not exist
     case E1.env. case E3.env. apply symmetry to H11.
     apply IH2_NV to H24 _ _ _. case T2.value. search. search.
 %letBind
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V
         IH1_NV IH2_NV IH1_V IH2_V Structure L_Is Eq.
  case_structure T2 in Eq with Structure. clear H13.
  Eq1: apply symmetry to H10. Eq2: apply symmetry to H11. clear H10 H11.
  case E.env.
    %E.value does not exist
     case E2.env.
       %E2.value does not exist
        case T1.value. apply IH2_NE_NV to Eq2 _ _ _.
        case T2.value. search.
       %E2.value exists
        apply IH1_NV to Eq1 _ _ _.
    %E.value exists
     case E2.env.
       %E2.value does not exist
        apply IH1_V to Eq1 _ _ _.
       %E.value exists
        apply IH1_V to Eq1 _ _ _. apply append_unique to H19 H24.
        case T1.value. apply IH2_NV to Eq2 _ _ _. case T2.value.
        search.
 %name
  intros Structure L_Is Eq. case_structure T2 in Eq with Structure.
  case T1.value. case T2.value.
    %lookup doesn't return for T2
     search.
    %lookup returns for T2
     assert exists Ret, lookup(Env2, L) = Ret. apply H12 to H16.
%Value Exists
 %intConst
  intros Structure N_Is Eq T1Env T2Env T1Val T2Val.
  case_structure T2 in Eq with Structure.
  case T1.value. case T2.value. search.
 %plus
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure Eq T1Env T2Env T1Val T2Val.
  case_structure T2 in Eq with Structure.
  case E.env. case E2.env. case T1.value.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8.
  apply IH1_V to Eq1 _ _ _. apply IH2_V to Eq2 _ _ _.
  apply attr_is to H22. apply attr_is to H23. case T2.value.
  apply plus_integer_unique to H21 H29. search.
 %minus
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure Eq T1Env T2Env T1Val T2Val.
  case_structure T2 in Eq with Structure.
  case E.env. case E2.env. case T1.value.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8.
  apply IH1_V to Eq1 _ _ _. apply IH2_V to Eq2 _ _ _.
  apply attr_is to H22. apply attr_is to H23. case T2.value.
  apply minus_integer_unique to H21 H29. search.
 %mult
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure Eq T1Env T2Env T1Val T2Val.
  case_structure T2 in Eq with Structure.
  case E.env. case E2.env. case T1.value.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8.
  apply IH1_V to Eq1 _ _ _. apply IH2_V to Eq2 _ _ _.
  apply attr_is to H22. apply attr_is to H23. case T2.value.
  apply multiply_integer_unique to H21 H29. search.
 %letBind
  intros IH1_NE_NV IH2_NE_NV IH1_NE_V IH2_NE_V IH1_NV IH2_NV
         IH1_V IH2_V Structure L_Is Eq T1Inv T2Env T1Val.
  case_structure T2 in Eq with Structure.
  Eq1: apply symmetry to H7. Eq2: apply symmetry to H8. clear H7 H8.
  case E.env.
    %E.value does not exist
     case E2.env.
       %E2.value does not exist
        case T1.value. apply IH2_NE_V to Eq2 _ _ _.
        case T2.value. search.
       %E2.value exists
        apply IH1_NV to Eq1 _ _ _.
    %E.value does exist
     case E2.env.
       %E2.value does not exist
        apply IH1_V to Eq1 _ _ _.
       %E2.value exists
        case T1.value. case T2.value.
          %E3.value does not exist
           apply IH1_V to Eq1 _ _ _. apply append_unique to H16 H21.
           apply IH2_V to Eq2 _ _ _.
          %E3.value exists
           apply IH1_V to Eq1 _ _ _. apply append_unique to H16 H21.
           apply IH2_V to Eq2 _ _ _. case T2.value. search.
 %name
  intros Structure L_Is Eq T1Env T2Env T1Val T2Val.
  case_structure T2 in Eq with Structure.
  case T1.value. case T2.value.
    %lookup does not return for T2
     assert exists Ret, lookup(Env2, L) = Ret. apply H12 to H13.
    %lookup does return for T2
     apply lookup__unique to H9 H12. search.

Split value_unique_lemmas__Expr as
  value_unique__no_env__no_value__Expr,
  value_unique__no_env__Expr,
  value_unique__no_value__Expr,
  value_unique__Expr.


Extensible_Theorem value_unique__Root :
  forall (R1 R2 : Root) V1 V2,
    R1 = R2 ->
    R1.value = V1 -> R2.value = V2 ->
    V1 = V2
on R1.
%root
 intros Structure Eq R1Val R2Val.
 case_structure R2 in Eq with Structure.
 apply symmetry to H6. case E.env. case E1.env. case R1.value.
 apply value_unique__Expr to H9 _ _ _. case R2.value. search.

Extensible_Theorem value_unique__no_value__Root :
  forall (R1 R2 : Root),
    R1 = R2 ->
    R1.value = <no value> ->
    R2.value = <no value>
on R1.
%root
 intros Structure Eq R1Val. case_structure R2 in Eq with Structure.
 apply symmetry to H6. case E.env. case E1.env. case R1.value.
 apply value_unique__no_value__Expr to H9 _ _ _. case R2.value.
 search.



Extensible_Theorem valExists__implies__value__Expr :
   forall T KNames Env,
      T.knownNames = KNames -> T.env = Env ->
      (forall Name, member Name KNames ->
          exists Val, member (Name, Val) Env) ->
      T.valExists = true -> exists V, T.value = V
on T.
split.
%intConst
 intros Structure. case T.value. exists N. search.
%plus
 intros IH1 IH2 Structure. case E.knownNames. case E.env.
 case T.valExists. apply IH1 to _ _ _ _.
 apply IH2 to _ _ _ _. case T.value. search.
%minus
 intros IH1 IH2 Structure. case E.knownNames. case E.env.
 case T.valExists. apply IH1 to _ _ _ _.
 apply IH2 to _ _ _ _. case T.value. search.
%mult
 intros IH1 IH2 Structure. case E.knownNames. case E.env.
 case T.valExists. apply IH1 to _ _ _ _.
 apply IH2 to _ _ _ _. case T.value. search.
%letBind
 intros IH1 IH2 Structure. case E.knownNames. case H12. case H14.
 case T.valExists. case T.value.
   %T.value does not exist because E1.value does not exist
    case E.env.
      %E1.env does not exist because E.value = <no value>
       apply IH1 to _ _ _ _.
      %env exists
       case H23. case H25. apply IH2 to H10 _ _ H17.
         %IH2 relate knownNames and env
          intros Mem. case Mem.
            %member first
             exists Value. search.
            %member rest
             apply H8 to H26. exists Val. search.
   %T.value exists
    search.
%name
 intros Structure. case T.valExists.
 apply contains__to__member to H10. apply H6 to H11.
 apply attr_is to H5. apply lookup__member to H13 H12.
 case T.value.
   %T.value = <no value> because lookup does not return
    assert exists Ret, lookup(Env1, L) = Ret. apply H17 to H18.
   %T.value exists
    search.


Extensible_Theorem valExists__implies__value__Root :
  forall (R : Root),
     R.valExists = true -> exists V, R.value = V
on R.
%root
 intros Structure. case R.valExists. case E.knownNames. case E.env.
 apply valExists__implies__value__Expr to H7 H8 _ H6.
   %member assumption for Expr theorem
    intros Mem. case Mem.
 case R.value. search.






%If knownNames exists, so does valExists
Extensible_Theorem knownNames__implies__valExists__Expr :
  forall T KnownNames,
     T.knownNames = KnownNames ->
     exists B, T.valExists = B
on T.
split.
%intConst
 intros Structure. case T.valExists. search.
%plus
 intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
   %T.valExists = E.valExists = <no value>
    apply IH1 to _.
   %T.valExists = E1.valExists = <no value>
    apply IH2 to _.
   %T.valExists = E1.valExists
    exists ValExists. search.
   %T.valExists = false
    exists false. search.
%minus
 intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
   %T.valExists = E.valExists = <no value>
    apply IH1 to _.
   %T.valExists = E1.valExists = <no value>
    apply IH2 to _.
   %T.valExists = E1.valExists
    exists ValExists. search.
   %T.valExists = false
    exists false. search.
%mult
 intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
   %T.valExists = E.valExists = <no value>
    apply IH1 to _.
   %T.valExists = E1.valExists = <no value>
    apply IH2 to _.
   %T.valExists = E1.valExists
    exists ValExists. search.
   %T.valExists = false
    exists false. search.
%letBind
 intros IH1 IH2 Structure. case E.knownNames. case T.valExists.
   %T.valExists = E.valExists = <no value>
    apply IH1 to _.
   %T.valExists = E1.valExists = <no value>
    apply IH2 to _.
   %T.valExists = E1.valExists
    exists ValExists. search.
   %T.valExists = false
    exists false. search.
%name
 intros Structure. case T.valExists.
   %contains does not return
    apply attr_is to H6. apply contains__total to H8 H3.
    assert (exists B, contains(L, KnownNames1) = B).
    apply H7 to H10.
   %contains returns a value
    exists FunResult. search.


Extensible_Theorem valExists__Root : forall (R : Root),
  exists B, R.valExists = B
on R.
%root
 intros Structure. case R.valExists.
   %T.valExists = E.valExists = <no value>
    case E.knownNames.
    apply knownNames__implies__valExists__Expr to H6.
   %T.valExists has a value
    exists ValExists. search.

