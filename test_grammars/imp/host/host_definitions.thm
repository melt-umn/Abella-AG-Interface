
Kind bool   type.
Kind nat   type.
Import "../../../silver_compilation/encodingPrimitives/integer_addition".
Import "../../../silver_compilation/encodingPrimitives/integer_multiplication".
Import "../../../silver_compilation/encodingPrimitives/integer_comparison".

Import "../../../silver_compilation/encodingPrimitives/lists".
Import "../../../silver_compilation/encodingPrimitives/strings".
Kind $pair   type -> type -> type.
Import "../../../silver_compilation/encodingPrimitives/pairs".
Kind $attrVal   type -> type.
Import "../../../silver_compilation/encodingPrimitives/attr_val".


Kind nt_A   type.
Kind nt_B   type.
Kind nt_C   type.

Type $prod_plus   nt_A -> nt_A -> nt_A.
Type $prod_num   integer -> nt_A.
Type $prod_name   (list $char) -> nt_A.
Type $prod_greater   nt_A -> nt_A -> nt_B.
Type $prod_equal   nt_A -> nt_A -> nt_B.
Type $prod_and   nt_B -> nt_B -> nt_B.
Type $prod_or   nt_B -> nt_B -> nt_B.
Type $prod_bTrue   nt_B.
Type $prod_bFalse   nt_B.
Type $prod_noop   nt_C.
Type $prod_seq   nt_C -> nt_C -> nt_C.
Type $prod_assign   (list $char) -> nt_A -> nt_C.
Type $prod_ifThenElse   nt_B -> nt_C -> nt_C -> nt_C.
Type $prod_while   nt_B -> nt_C -> nt_C.


Kind node_A   type.
Kind node_B   type.
Kind node_C   type.


Kind $node_tree   type.

Type $ntr_nt_A   node_A -> list $node_tree -> $node_tree.
Type $ntr_nt_B   node_B -> list $node_tree -> $node_tree.
Type $ntr_nt_C   node_C -> list $node_tree -> $node_tree.


Type $access_$_env_$_nt_A   nt_A -> node_A -> $attrVal (list ($pair (list $char) integer)) -> prop.
Type $access_$_env_$_nt_B   nt_B -> node_B -> $attrVal (list ($pair (list $char) integer)) -> prop.
Type $access_$_env_$_nt_C   nt_C -> node_C -> $attrVal (list ($pair (list $char) integer)) -> prop.
Type $access_$_value_$_nt_A   nt_A -> node_A -> $attrVal integer -> prop.
Type $access_$_value_$_nt_B   nt_B -> node_B -> $attrVal bool -> prop.
Type $access_$_env_out_$_nt_C   nt_C -> node_C -> $attrVal (list ($pair (list $char) integer)) -> prop.

Type $local_access_$_$prod_while_$_subWhile_$_nt_C   nt_C -> node_C -> $attrVal ($pair nt_C $node_tree) -> prop.


Type $env$_is_inherited   prop.


Type $structure_eq__nt_A   nt_A -> nt_A -> prop.
Type $structure_eq__nt_B   nt_B -> nt_B -> prop.
Type $structure_eq__nt_C   nt_C -> nt_C -> prop.

Define $structure_eq__nt_A__host : nt_A -> nt_A -> prop by
  $structure_eq__nt_A__host ($prod_plus A2 A) ($prod_plus A3 A1) :=
     $structure_eq__nt_A A2 A3 /\
     $structure_eq__nt_A A A1;
  $structure_eq__nt_A__host ($prod_num N) ($prod_num N);
  $structure_eq__nt_A__host ($prod_name L) ($prod_name L).
Define $structure_eq__nt_B__host : nt_B -> nt_B -> prop by
  $structure_eq__nt_B__host ($prod_greater A2 A) ($prod_greater A3 A1) :=
     $structure_eq__nt_A A2 A3 /\
     $structure_eq__nt_A A A1;
  $structure_eq__nt_B__host ($prod_equal A2 A) ($prod_equal A3 A1) :=
     $structure_eq__nt_A A2 A3 /\
     $structure_eq__nt_A A A1;
  $structure_eq__nt_B__host ($prod_and B2 B) ($prod_and B3 B1) :=
     $structure_eq__nt_B B2 B3 /\
     $structure_eq__nt_B B B1;
  $structure_eq__nt_B__host ($prod_or B2 B) ($prod_or B3 B1) :=
     $structure_eq__nt_B B2 B3 /\
     $structure_eq__nt_B B B1;
  $structure_eq__nt_B__host ($prod_bTrue ) ($prod_bTrue );
  $structure_eq__nt_B__host ($prod_bFalse ) ($prod_bFalse ).
Define $structure_eq__nt_C__host : nt_C -> nt_C -> prop by
  $structure_eq__nt_C__host ($prod_noop ) ($prod_noop );
  $structure_eq__nt_C__host ($prod_seq C2 C) ($prod_seq C3 C1) :=
     $structure_eq__nt_C C2 C3 /\
     $structure_eq__nt_C C C1;
  $structure_eq__nt_C__host ($prod_assign L A) ($prod_assign L A1) :=
     $structure_eq__nt_A A A1;
  $structure_eq__nt_C__host ($prod_ifThenElse B C2 C) ($prod_ifThenElse B1 C3 C1) :=
     $structure_eq__nt_B B B1 /\
     $structure_eq__nt_C C2 C3 /\
     $structure_eq__nt_C C C1;
  $structure_eq__nt_C__host ($prod_while B C) ($prod_while B1 C1) :=
     $structure_eq__nt_B B B1 /\
     $structure_eq__nt_C C C1.


Type $env__nt_A   nt_A -> nt_A -> $node_tree -> prop.
Type $env__nt_B   nt_B -> nt_B -> $node_tree -> prop.
Type $env__nt_C   nt_C -> nt_C -> $node_tree -> prop.
Type $value__nt_A   nt_A -> nt_A -> $node_tree -> prop.
Type $value__nt_B   nt_B -> nt_B -> $node_tree -> prop.
Type $env_out__nt_C   nt_C -> nt_C -> $node_tree -> prop.

Type $wpd_node_nt_A   nt_A -> $node_tree -> prop.
Type $wpd_nt_A   nt_A -> $node_tree -> prop.
Type $wpd_node_nt_B   nt_B -> $node_tree -> prop.
Type $wpd_nt_B   nt_B -> $node_tree -> prop.
Type $wpd_node_nt_C   nt_C -> $node_tree -> prop.
Type $wpd_nt_C   nt_C -> $node_tree -> prop.


Define $fun__lookup :
       list $char -> list ($pair (list $char) integer) ->
       integer -> prop by
  $fun__lookup N (($pair_c N Val)::Tail) Val;
  $fun__lookup N (($pair_c Name Val)::Tail) Result :=
     (Name = N -> false) /\
     $fun__lookup N Tail Result.


Define $env__nt_A__host : nt_A -> nt_A -> $node_tree -> prop by
  %plus
  $env__nt_A__host TreeName ($prod_plus A1 A2)
                   ($ntr_nt_A Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     $access_$_env_$_nt_A TreeName Node $attr_no /\
     $access_$_env_$_nt_A A1 A1Node $attr_no /\
     $access_$_env_$_nt_A A2 A2Node $attr_no;
  $env__nt_A__host TreeName ($prod_plus A1 A2)
                   ($ntr_nt_A Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     exists Env,
        $access_$_env_$_nt_A TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_A A1 A1Node ($attr_ex Env) /\
        $access_$_env_$_nt_A A2 A2Node ($attr_ex Env);
  %num
  $env__nt_A__host TreeName ($prod_num N) ($ntr_nt_A Node nil);
  %name
  $env__nt_A__host TreeName ($prod_name N) ($ntr_nt_A Node nil).

Define $value__nt_A__host : nt_A -> nt_A -> $node_tree -> prop by
  %plus
  $value__nt_A__host TreeName ($prod_plus A1 A2)
                   ($ntr_nt_A Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     $access_$_value_$_nt_A TreeName Node $attr_no /\
     $access_$_value_$_nt_A A1 A1Node $attr_no;
  $value__nt_A__host TreeName ($prod_plus A1 A2)
                   ($ntr_nt_A Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     exists Val,
        $access_$_value_$_nt_A TreeName Node $attr_no /\
        $access_$_value_$_nt_A A1 A1Node ($attr_ex Val) /\
        $access_$_value_$_nt_A A2 A2Node $attr_no;
  $value__nt_A__host TreeName ($prod_plus A1 A2)
                   ($ntr_nt_A Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     exists Val1 Val2 PlusResult,
        $access_$_value_$_nt_A TreeName Node ($attr_ex PlusResult) /\
        $access_$_value_$_nt_A A1 A1Node ($attr_ex Val1) /\
        $access_$_value_$_nt_A A2 A2Node ($attr_ex Val2) /\
        $plus_integer Val1 Val2 PlusResult;
  %num
  $value__nt_A__host TreeName ($prod_num N) ($ntr_nt_A Node nil) :=
     $access_$_value_$_nt_A TreeName Node ($attr_ex N);
  %name
  $value__nt_A__host TreeName ($prod_name S) ($ntr_nt_A Node nil) :=
     $access_$_value_$_nt_A TreeName Node $attr_no /\
     $access_$_env_$_nt_A TreeName Node $attr_no;
  $value__nt_A__host TreeName ($prod_name S) ($ntr_nt_A Node nil) :=
     exists Env,
        $access_$_value_$_nt_A TreeName Node $attr_no /\
        $access_$_env_$_nt_A TreeName Node ($attr_ex Env) /\
        ((exists Ret, $fun__lookup S Env Ret) -> false);
  $value__nt_A__host TreeName ($prod_name S) ($ntr_nt_A Node nil) :=
     exists Env Ret,
        $access_$_value_$_nt_A TreeName Node ($attr_ex Ret) /\
        $access_$_env_$_nt_A TreeName Node ($attr_ex Env) /\
        $fun__lookup S Env Ret.


Define $env__nt_B__host : nt_B -> nt_B -> $node_tree -> prop by
  %greater
  $env__nt_B__host TreeName ($prod_greater A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     $access_$_env_$_nt_B TreeName Node $attr_no /\
     $access_$_env_$_nt_A A1 A1Node $attr_no /\
     $access_$_env_$_nt_A A2 A2Node $attr_no;
  $env__nt_B__host TreeName ($prod_greater A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     exists Env,
        $access_$_env_$_nt_B TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_A A1 A1Node ($attr_ex Env) /\
        $access_$_env_$_nt_A A2 A2Node ($attr_ex Env);
  %equal
  $env__nt_B__host TreeName ($prod_equal A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     $access_$_env_$_nt_B TreeName Node $attr_no /\
     $access_$_env_$_nt_A A1 A1Node $attr_no /\
     $access_$_env_$_nt_A A2 A2Node $attr_no;
  $env__nt_B__host TreeName ($prod_equal A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     exists Env,
        $access_$_env_$_nt_B TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_A A1 A1Node ($attr_ex Env) /\
        $access_$_env_$_nt_A A2 A2Node ($attr_ex Env);
  %and
  $env__nt_B__host TreeName ($prod_and B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     $access_$_env_$_nt_B TreeName Node $attr_no /\
     $access_$_env_$_nt_B B1 B1Node $attr_no /\
     $access_$_env_$_nt_B B2 B2Node $attr_no;
  $env__nt_B__host TreeName ($prod_and B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     exists Env,
        $access_$_env_$_nt_B TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_B B1 B1Node ($attr_ex Env) /\
        $access_$_env_$_nt_B B2 B2Node ($attr_ex Env);
  %or
  $env__nt_B__host TreeName ($prod_or B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     $access_$_env_$_nt_B TreeName Node $attr_no /\
     $access_$_env_$_nt_B B1 B1Node $attr_no /\
     $access_$_env_$_nt_B B2 B2Node $attr_no;
  $env__nt_B__host TreeName ($prod_or B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     exists Env,
        $access_$_env_$_nt_B TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_B B1 B1Node ($attr_ex Env) /\
        $access_$_env_$_nt_B B2 B2Node ($attr_ex Env);
  %bTrue
  $env__nt_B__host TreeName $prod_bTrue ($ntr_nt_B Node nil);
  %bFalse
  $env__nt_B__host TreeName $prod_bFalse ($ntr_nt_B Node nil).

Define $value__nt_B__host : nt_B -> nt_B -> $node_tree -> prop by
  %greater
  $value__nt_B__host TreeName ($prod_greater A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     $access_$_value_$_nt_B TreeName Node $attr_no /\
     $access_$_value_$_nt_A A1 A1Node $attr_no;
  $value__nt_B__host TreeName ($prod_greater A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     exists Val,
        $access_$_value_$_nt_B TreeName Node $attr_no /\
        $access_$_value_$_nt_A A1 A1Node ($attr_ex Val) /\
        $access_$_value_$_nt_A A2 A2Node $attr_no;
  $value__nt_B__host TreeName ($prod_greater A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     exists Val1 Val2 GreaterResult,
        $access_$_value_$_nt_B TreeName Node
                                 ($attr_ex GreaterResult) /\
        $access_$_value_$_nt_A A1 A1Node ($attr_ex Val1) /\
        $access_$_value_$_nt_A A2 A2Node ($attr_ex Val2) /\
        $greater_integer Val1 Val2 GreaterResult;
  %equal
  $value__nt_B__host TreeName ($prod_equal A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     $access_$_value_$_nt_B TreeName Node $attr_no /\
     $access_$_value_$_nt_A A1 A1Node $attr_no;
  $value__nt_B__host TreeName ($prod_equal A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     exists Val,
        $access_$_value_$_nt_B TreeName Node $attr_no /\
        $access_$_value_$_nt_A A1 A1Node ($attr_ex Val) /\
        $access_$_value_$_nt_A A2 A2Node $attr_no;
  $value__nt_B__host TreeName ($prod_equal A1 A2)
                   ($ntr_nt_B Node ($ntr_nt_A A1Node A1CL::
                                    $ntr_nt_A A2Node A2CL::nil)) :=
     exists Val,
        $access_$_value_$_nt_B TreeName Node ($attr_ex $btrue) /\
        $access_$_value_$_nt_A A1 A1Node ($attr_ex Val) /\
        $access_$_value_$_nt_A A2 A2Node ($attr_ex Val);
  %and
  $value__nt_B__host TreeName ($prod_and B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     $access_$_value_$_nt_B TreeName Node $attr_no /\
     $access_$_value_$_nt_B B1 B1Node $attr_no;
  $value__nt_B__host TreeName ($prod_and B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     $access_$_value_$_nt_B TreeName Node $attr_no /\
     $access_$_value_$_nt_B B1 B1Node ($attr_ex $btrue) /\
     $access_$_value_$_nt_B B2 B2Node $attr_no;
  $value__nt_B__host TreeName ($prod_and B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     exists Val,
        $access_$_value_$_nt_B TreeName Node ($attr_ex Val) /\
        $access_$_value_$_nt_B B1 B1Node ($attr_ex $btrue) /\
        $access_$_value_$_nt_B B2 B2Node ($attr_ex Val);
  $value__nt_B__host TreeName ($prod_and B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     $access_$_value_$_nt_B TreeName Node ($attr_ex $bfalse) /\
     $access_$_value_$_nt_B B1 B1Node ($attr_ex $bfalse);
  %or
  $value__nt_B__host TreeName ($prod_or B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     $access_$_value_$_nt_B TreeName Node $attr_no /\
     $access_$_value_$_nt_B B1 B1Node $attr_no;
  $value__nt_B__host TreeName ($prod_or B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     $access_$_value_$_nt_B TreeName Node $attr_no /\
     $access_$_value_$_nt_B B1 B1Node ($attr_ex $bfalse) /\
     $access_$_value_$_nt_B B2 B2Node $attr_no;
  $value__nt_B__host TreeName ($prod_or B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     exists Val,
        $access_$_value_$_nt_B TreeName Node ($attr_ex Val) /\
        $access_$_value_$_nt_B B1 B1Node ($attr_ex $bfalse) /\
        $access_$_value_$_nt_B B2 B2Node ($attr_ex Val);
  $value__nt_B__host TreeName ($prod_or B1 B2)
                   ($ntr_nt_B Node ($ntr_nt_B B1Node B1CL::
                                    $ntr_nt_B B2Node B2CL::nil)) :=
     $access_$_value_$_nt_B TreeName Node ($attr_ex $btrue) /\
     $access_$_value_$_nt_B B1 B1Node ($attr_ex $btrue);
  %bTrue
  $value__nt_B__host TreeName $prod_bTrue ($ntr_nt_B Node nil) :=
     $access_$_value_$_nt_B TreeName Node ($attr_ex $btrue);
  %bFalse
  $value__nt_B__host TreeName $prod_bFalse ($ntr_nt_B Node nil) :=
     $access_$_value_$_nt_B TreeName Node ($attr_ex $bfalse).


Define $env__nt_C__host : nt_C -> nt_C -> $node_tree -> prop by
  %noop
  $env__nt_C__host TreeName $prod_noop ($ntr_nt_C Node nil);
  %seq
  $env__nt_C__host TreeName ($prod_seq C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     $access_$_env_$_nt_C TreeName Node $attr_no /\
     $access_$_env_$_nt_C C1 C1Node $attr_no /\
     $access_$_env_out_$_nt_C C1 C1Node $attr_no /\
     $access_$_env_$_nt_C C2 C2Node $attr_no;
  $env__nt_C__host TreeName ($prod_seq C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     exists EnvOut,
        $access_$_env_$_nt_C TreeName Node $attr_no /\
        $access_$_env_$_nt_C C1 C1Node $attr_no /\
        $access_$_env_out_$_nt_C C1 C1Node ($attr_ex EnvOut) /\
        $access_$_env_$_nt_C C2 C2Node ($attr_ex EnvOut);
  $env__nt_C__host TreeName ($prod_seq C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     exists Env,
        $access_$_env_$_nt_C TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_C C1 C1Node ($attr_ex Env) /\
        $access_$_env_out_$_nt_C C1 C1Node $attr_no /\
        $access_$_env_$_nt_C C2 C2Node $attr_no;
  $env__nt_C__host TreeName ($prod_seq C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     exists Env EnvOut,
        $access_$_env_$_nt_C TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_C C1 C1Node ($attr_ex Env) /\
        $access_$_env_out_$_nt_C C1 C1Node ($attr_ex EnvOut) /\
        $access_$_env_$_nt_C C2 C2Node ($attr_ex EnvOut);
  %assign
  $env__nt_C__host TreeName ($prod_assign N A)
                   ($ntr_nt_C Node ($ntr_nt_A ANode ACL::nil)) :=
     $access_$_env_$_nt_C TreeName Node $attr_no /\
     $access_$_env_$_nt_A A ANode $attr_no;
  $env__nt_C__host TreeName ($prod_assign N A)
                   ($ntr_nt_C Node ($ntr_nt_A ANode ACL::nil)) :=
     exists Env,
        $access_$_env_$_nt_C TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_A A ANode ($attr_ex Env);
  %ifThenElse
  $env__nt_C__host TreeName ($prod_ifThenElse B C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     $access_$_env_$_nt_C TreeName Node $attr_no /\
     $access_$_env_$_nt_B B BNode $attr_no /\
     $access_$_env_$_nt_C C1 C1Node $attr_no /\
     $access_$_env_$_nt_C C2 C2Node $attr_no;
  $env__nt_C__host TreeName ($prod_ifThenElse B C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     exists Env,
        $access_$_env_$_nt_C TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_B B BNode ($attr_ex Env) /\
        $access_$_env_$_nt_C C1 C1Node ($attr_ex Env) /\
        $access_$_env_$_nt_C C2 C2Node ($attr_ex Env);
  %while
  $env__nt_C__host TreeName ($prod_while B C)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C CNode CCL::nil)) :=
     $access_$_env_$_nt_C TreeName Node $attr_no /\
     $access_$_env_$_nt_B B BNode $attr_no /\
     $access_$_env_$_nt_C C CNode $attr_no;
  $env__nt_C__host TreeName ($prod_while B C)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C CNode CCL::nil)) :=
     exists Env,
        $access_$_env_$_nt_C TreeName  Node ($attr_ex Env) /\
        $access_$_env_$_nt_B B BNode ($attr_ex Env) /\
        $access_$_env_$_nt_C C CNode ($attr_ex Env).

Define $env_out__nt_C__host : nt_C -> nt_C -> $node_tree -> prop by
  %noop
  $env_out__nt_C__host TreeName $prod_noop ($ntr_nt_C Node nil) :=
     $access_$_env_out_$_nt_C TreeName Node $attr_no /\
     $access_$_env_$_nt_C TreeName Node $attr_no;
  $env_out__nt_C__host TreeName $prod_noop ($ntr_nt_C Node nil) :=
     exists Env,
        $access_$_env_out_$_nt_C TreeName Node ($attr_ex Env) /\
        $access_$_env_$_nt_C TreeName Node ($attr_ex Env);
  %seq
  $env_out__nt_C__host TreeName ($prod_seq C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     $access_$_env_out_$_nt_C TreeName Node $attr_no /\
     $access_$_env_out_$_nt_C C2 C2Node $attr_no;
  $env_out__nt_C__host TreeName ($prod_seq C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     exists EnvOut,
        $access_$_env_out_$_nt_C TreeName Node ($attr_ex EnvOut) /\
        $access_$_env_out_$_nt_C C2 C2Node ($attr_ex EnvOut);
  %assign
  $env_out__nt_C__host TreeName ($prod_assign N A)
                   ($ntr_nt_C Node ($ntr_nt_A ANode ACL::nil)) :=
     $access_$_env_out_$_nt_C TreeName Node $attr_no /\
     $access_$_value_$_nt_A A ANode $attr_no;
  $env_out__nt_C__host TreeName ($prod_assign N A)
                   ($ntr_nt_C Node ($ntr_nt_A ANode ACL::nil)) :=
     exists Val,
        $access_$_env_out_$_nt_C TreeName Node $attr_no /\
        $access_$_value_$_nt_A A ANode ($attr_ex Val) /\
        $access_$_env_$_nt_C TreeName Node $attr_no;
  $env_out__nt_C__host TreeName ($prod_assign N A)
                   ($ntr_nt_C Node ($ntr_nt_A ANode ACL::nil)) :=
     exists Val Env,
        $access_$_env_out_$_nt_C TreeName Node
                                 ($attr_ex ($pair_c N Val::Env)) /\
        $access_$_value_$_nt_A A ANode ($attr_ex Val) /\
        $access_$_env_$_nt_C TreeName Node ($attr_ex Env);
  %ifThenElse
  $env_out__nt_C__host TreeName ($prod_ifThenElse B C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     $access_$_env_out_$_nt_C TreeName Node $attr_no /\
     $access_$_value_$_nt_B B BNode $attr_no;
  $env_out__nt_C__host TreeName ($prod_ifThenElse B C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     $access_$_env_out_$_nt_C TreeName Node $attr_no /\
     $access_$_value_$_nt_B B BNode ($attr_ex $btrue) /\
     $access_$_env_out_$_nt_C C1 C1Node $attr_no;
  $env_out__nt_C__host TreeName ($prod_ifThenElse B C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     $access_$_env_out_$_nt_C TreeName Node $attr_no /\
     $access_$_value_$_nt_B B BNode ($attr_ex $bfalse) /\
     $access_$_env_out_$_nt_C C2 C2Node $attr_no;
  $env_out__nt_C__host TreeName ($prod_ifThenElse B C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     exists EnvOut,
        $access_$_env_out_$_nt_C TreeName Node ($attr_ex EnvOut) /\
        $access_$_value_$_nt_B B BNode ($attr_ex $btrue) /\
        $access_$_env_out_$_nt_C C1 C1Node ($attr_ex EnvOut);
  $env_out__nt_C__host TreeName ($prod_ifThenElse B C1 C2)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C C1Node C1CL::
                                    $ntr_nt_C C2Node C2CL::nil)) :=
     exists EnvOut,
        $access_$_env_out_$_nt_C TreeName Node ($attr_ex EnvOut) /\
        $access_$_value_$_nt_B B BNode ($attr_ex $bfalse) /\
        $access_$_env_out_$_nt_C C2 C2Node ($attr_ex EnvOut);
  %while
  $env_out__nt_C__host TreeName ($prod_while B C)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C CNode CCL::nil)) :=
     $access_$_env_out_$_nt_C TreeName Node $attr_no /\
     $access_$_value_$_nt_B B BNode $attr_no;
  $env_out__nt_C__host TreeName ($prod_while B C)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C CNode CCL::nil)) :=
     $access_$_env_out_$_nt_C TreeName Node $attr_no /\
     $access_$_value_$_nt_B B BNode ($attr_ex $btrue) /\
     $local_access_$_$prod_while_$_subWhile_$_nt_C TreeName Node
                                                   $attr_no;
  $env_out__nt_C__host TreeName ($prod_while B C)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C CNode CCL::nil)) :=
     exists SubWhile Node_SubWhile ChildList_SubWhile,
        $access_$_env_out_$_nt_C TreeName Node $attr_no /\
        $access_$_value_$_nt_B B BNode ($attr_ex $btrue) /\
        $local_access_$_$prod_while_$_subWhile_$_nt_C TreeName Node
                  ($attr_ex ($pair_c SubWhile
                                    ($ntr_nt_C Node_SubWhile
                                          ChildList_SubWhile))) /\
        $access_$_env_out_$_nt_C SubWhile Node_SubWhile $attr_no;
  $env_out__nt_C__host TreeName ($prod_while B C)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C CNode CCL::nil)) :=
     exists Env,
        $access_$_env_out_$_nt_C TreeName Node ($attr_ex Env) /\
        $access_$_value_$_nt_B B BNode ($attr_ex $bfalse) /\
        $access_$_env_$_nt_C TreeName Node ($attr_ex Env);
  $env_out__nt_C__host TreeName ($prod_while B C)
                   ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                    $ntr_nt_C CNode CCL::nil)) :=
     exists EnvOut SubWhile Node_SubWhile ChildList_SubWhile,
        $access_$_env_out_$_nt_C TreeName Node ($attr_ex EnvOut) /\
        $access_$_value_$_nt_B B BNode ($attr_ex $btrue) /\
        $local_access_$_$prod_while_$_subWhile_$_nt_C TreeName Node
                  ($attr_ex ($pair_c SubWhile
                                    ($ntr_nt_C Node_SubWhile
                                          ChildList_SubWhile))) /\
        $access_$_env_out_$_nt_C SubWhile Node_SubWhile
                                 ($attr_ex EnvOut).

Define $while_local_subWhile : nt_C -> nt_C -> $node_tree -> prop by
  %non-while productions
  $while_local_subWhile TreeName Term ($ntr_nt_C Node CL) :=
     ((exists B C, Term = $prod_while B C) -> false) /\
     $local_access_$_$prod_while_$_subWhile_$_nt_C TreeName Node
                                                            $attr_no;
  %while
  $while_local_subWhile TreeName ($prod_while B C)
                        ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                         $ntr_nt_C CNode CCL::nil)) :=
     $local_access_$_$prod_while_$_subWhile_$_nt_C TreeName Node
                                                   $attr_no /\
     $access_$_value_$_nt_B B BNode ($attr_ex $bfalse);
  $while_local_subWhile TreeName ($prod_while B C)
                        ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                         $ntr_nt_C CNode CCL::nil)) :=
     exists SubWhile Node_SubWhile ChildList_SubWhile,
        $local_access_$_$prod_while_$_subWhile_$_nt_C TreeName Node
                  ($attr_ex ($pair_c SubWhile
                                ($ntr_nt_C Node_SubWhile
                                           ChildList_SubWhile))) /\
        $structure_eq__nt_C SubWhile ($prod_while B C) /\
        $access_$_value_$_nt_B B BNode ($attr_ex $btrue) /\
        $wpd_nt_C SubWhile ($ntr_nt_C Node_SubWhile
                                          ChildList_SubWhile) /\
        $access_$_env_out_$_nt_C C CNode $attr_no /\
        $access_$_env_$_nt_C SubWhile Node_SubWhile $attr_no;
  $while_local_subWhile TreeName ($prod_while B C)
                        ($ntr_nt_C Node ($ntr_nt_B BNode BCL::
                                         $ntr_nt_C CNode CCL::nil)) :=
     exists SubWhile Node_SubWhile ChildList_SubWhile Env,
        $local_access_$_$prod_while_$_subWhile_$_nt_C TreeName Node
                  ($attr_ex ($pair_c SubWhile
                                ($ntr_nt_C Node_SubWhile
                                           ChildList_SubWhile))) /\
        $structure_eq__nt_C SubWhile ($prod_while B C) /\
        $access_$_value_$_nt_B B BNode ($attr_ex $btrue) /\
        $wpd_nt_C SubWhile ($ntr_nt_C Node_SubWhile
                                          ChildList_SubWhile) /\
        $access_$_env_out_$_nt_C C CNode ($attr_ex Env) /\
        $access_$_env_$_nt_C SubWhile Node_SubWhile ($attr_ex Env).


Define $split : (A -> B -> prop) -> ($pair A B) -> prop by
  $split SubRel ($pair_c A B) :=
     SubRel A B.

Define $wpd_node_nt_A__host : nt_A -> $node_tree -> prop by
   $wpd_node_nt_A__host Tree ($ntr_nt_A Node CL) :=
      exists Aenv Avalue,
         $env__nt_A Tree Tree ($ntr_nt_A Node CL) /\
            $access_$_env_$_nt_A Tree Node Aenv /\
            $is_attrVal (is_list (is_pair (is_string) (is_integer))) Aenv /\
         $value__nt_A Tree Tree ($ntr_nt_A Node CL) /\
            $access_$_value_$_nt_A Tree Node Avalue /\
            $is_attrVal (is_integer) Avalue.
Define $wpd_node_nt_B__host : nt_B -> $node_tree -> prop by
   $wpd_node_nt_B__host Tree ($ntr_nt_B Node CL) :=
      exists Aenv Avalue,
         $env__nt_B Tree Tree ($ntr_nt_B Node CL) /\
            $access_$_env_$_nt_B Tree Node Aenv /\
            $is_attrVal (is_list (is_pair (is_string) (is_integer))) Aenv /\
         $value__nt_B Tree Tree ($ntr_nt_B Node CL) /\
            $access_$_value_$_nt_B Tree Node Avalue /\
            $is_attrVal (is_bool) Avalue.
Define $wpd_node_nt_C__host : nt_C -> $node_tree -> prop by
   $wpd_node_nt_C__host Tree ($ntr_nt_C Node CL) :=
      exists Aenv Aenv_out AsubWhile,
         $env__nt_C Tree Tree ($ntr_nt_C Node CL) /\
            $access_$_env_$_nt_C Tree Node Aenv /\
            $is_attrVal (is_list (is_pair (is_string) (is_integer))) Aenv /\
         $env_out__nt_C Tree Tree ($ntr_nt_C Node CL) /\
            $access_$_env_out_$_nt_C Tree Node Aenv_out /\
            $is_attrVal (is_list (is_pair (is_string) (is_integer))) Aenv_out /\
         $while_local_subWhile Tree Tree ($ntr_nt_C Node CL) /\
            $local_access_$_$prod_while_$_subWhile_$_nt_C Tree Node AsubWhile /\
            $is_attrVal ($split $wpd_nt_C) AsubWhile.

Define $wpd_nt_A__host : nt_A -> $node_tree -> prop by
  $wpd_nt_A__host ($prod_plus A1 A) ($ntr_nt_A Node (A1Ntr::ANtr::nil)) :=
     $wpd_node_nt_A ($prod_plus A1 A) ($ntr_nt_A Node (A1Ntr::ANtr::nil)) /\
     $wpd_nt_A A1 A1Ntr /\
     $wpd_nt_A A ANtr;
  $wpd_nt_A__host ($prod_num N) ($ntr_nt_A Node (nil)) :=
     $wpd_node_nt_A ($prod_num N) ($ntr_nt_A Node (nil)) /\
     is_integer N;
  $wpd_nt_A__host ($prod_name L) ($ntr_nt_A Node (nil)) :=
     $wpd_node_nt_A ($prod_name L) ($ntr_nt_A Node (nil)) /\
     is_string L.
Define $wpd_nt_B__host : nt_B -> $node_tree -> prop by
  $wpd_nt_B__host ($prod_greater A1 A) ($ntr_nt_B Node (A1Ntr::ANtr::nil)) :=
     $wpd_node_nt_B ($prod_greater A1 A) ($ntr_nt_B Node (A1Ntr::ANtr::nil)) /\
     $wpd_nt_A A1 A1Ntr /\
     $wpd_nt_A A ANtr;
  $wpd_nt_B__host ($prod_equal A1 A) ($ntr_nt_B Node (A1Ntr::ANtr::nil)) :=
     $wpd_node_nt_B ($prod_equal A1 A) ($ntr_nt_B Node (A1Ntr::ANtr::nil)) /\
     $wpd_nt_A A1 A1Ntr /\
     $wpd_nt_A A ANtr;
  $wpd_nt_B__host ($prod_and B1 B) ($ntr_nt_B Node (B1Ntr::BNtr::nil)) :=
     $wpd_node_nt_B ($prod_and B1 B) ($ntr_nt_B Node (B1Ntr::BNtr::nil)) /\
     $wpd_nt_B B1 B1Ntr /\
     $wpd_nt_B B BNtr;
  $wpd_nt_B__host ($prod_or B1 B) ($ntr_nt_B Node (B1Ntr::BNtr::nil)) :=
     $wpd_node_nt_B ($prod_or B1 B) ($ntr_nt_B Node (B1Ntr::BNtr::nil)) /\
     $wpd_nt_B B1 B1Ntr /\
     $wpd_nt_B B BNtr;
  $wpd_nt_B__host ($prod_bTrue ) ($ntr_nt_B Node (nil)) :=
     $wpd_node_nt_B ($prod_bTrue ) ($ntr_nt_B Node (nil));
  $wpd_nt_B__host ($prod_bFalse ) ($ntr_nt_B Node (nil)) :=
     $wpd_node_nt_B ($prod_bFalse ) ($ntr_nt_B Node (nil)).
Define $wpd_nt_C__host : nt_C -> $node_tree -> prop by
  $wpd_nt_C__host ($prod_noop ) ($ntr_nt_C Node (nil)) :=
     $wpd_node_nt_C ($prod_noop ) ($ntr_nt_C Node (nil));
  $wpd_nt_C__host ($prod_seq C1 C) ($ntr_nt_C Node (C1Ntr::CNtr::nil)) :=
     $wpd_node_nt_C ($prod_seq C1 C) ($ntr_nt_C Node (C1Ntr::CNtr::nil)) /\
     $wpd_nt_C C1 C1Ntr /\
     $wpd_nt_C C CNtr;
  $wpd_nt_C__host ($prod_assign L A) ($ntr_nt_C Node (ANtr::nil)) :=
     $wpd_node_nt_C ($prod_assign L A) ($ntr_nt_C Node (ANtr::nil)) /\
     is_string L /\
     $wpd_nt_A A ANtr;
  $wpd_nt_C__host ($prod_ifThenElse B C1 C) ($ntr_nt_C Node (BNtr::C1Ntr::CNtr::nil)) :=
     $wpd_node_nt_C ($prod_ifThenElse B C1 C) ($ntr_nt_C Node (BNtr::C1Ntr::CNtr::nil)) /\
     $wpd_nt_B B BNtr /\
     $wpd_nt_C C1 C1Ntr /\
     $wpd_nt_C C CNtr;
  $wpd_nt_C__host ($prod_while B C) ($ntr_nt_C Node (BNtr::CNtr::nil)) :=
     $wpd_node_nt_C ($prod_while B C) ($ntr_nt_C Node (BNtr::CNtr::nil)) /\
     $wpd_nt_B B BNtr /\
     $wpd_nt_C C CNtr.


Theorem $access_$_env_$_nt_A__unique : forall Tree Node V V',
   $access_$_env_$_nt_A Tree Node V ->
   $access_$_env_$_nt_A Tree Node V' -> V = V'.
skip.
Theorem $access_$_env_$_nt_B__unique : forall Tree Node V V',
   $access_$_env_$_nt_B Tree Node V ->
   $access_$_env_$_nt_B Tree Node V' -> V = V'.
skip.
Theorem $access_$_env_$_nt_C__unique : forall Tree Node V V',
   $access_$_env_$_nt_C Tree Node V ->
   $access_$_env_$_nt_C Tree Node V' -> V = V'.
skip.
Theorem $access_$_value_$_nt_A__unique : forall Tree Node V V',
   $access_$_value_$_nt_A Tree Node V ->
   $access_$_value_$_nt_A Tree Node V' -> V = V'.
skip.
Theorem $access_$_value_$_nt_B__unique : forall Tree Node V V',
   $access_$_value_$_nt_B Tree Node V ->
   $access_$_value_$_nt_B Tree Node V' -> V = V'.
skip.
Theorem $access_$_env_out_$_nt_C__unique : forall Tree Node V V',
   $access_$_env_out_$_nt_C Tree Node V ->
   $access_$_env_out_$_nt_C Tree Node V' -> V = V'.
skip.
Theorem $local_access_$_$prod_while_$_subWhile_$_nt_C__unique : forall Tree Node V V',
   $local_access_$_$prod_while_$_subWhile_$_nt_C Tree Node V ->
   $local_access_$_$prod_while_$_subWhile_$_nt_C Tree Node V' -> V = V'.
skip.


Theorem $access_$_env_$_nt_A__is : forall Tree Node CL V,
   $wpd_nt_A Tree ($ntr_nt_A Node CL) ->
   $access_$_env_$_nt_A Tree Node ($attr_ex V) ->
   is_list (is_pair (is_string) (is_integer)) V.
skip.
Theorem $access_$_env_$_nt_B__is : forall Tree Node CL V,
   $wpd_nt_B Tree ($ntr_nt_B Node CL) ->
   $access_$_env_$_nt_B Tree Node ($attr_ex V) ->
   is_list (is_pair (is_string) (is_integer)) V.
skip.
Theorem $access_$_env_$_nt_C__is : forall Tree Node CL V,
   $wpd_nt_C Tree ($ntr_nt_C Node CL) ->
   $access_$_env_$_nt_C Tree Node ($attr_ex V) ->
   is_list (is_pair (is_string) (is_integer)) V.
skip.
Theorem $access_$_value_$_nt_A__is : forall Tree Node CL V,
   $wpd_nt_A Tree ($ntr_nt_A Node CL) ->
   $access_$_value_$_nt_A Tree Node ($attr_ex V) ->
   is_integer V.
skip.
Theorem $access_$_value_$_nt_B__is : forall Tree Node CL V,
   $wpd_nt_B Tree ($ntr_nt_B Node CL) ->
   $access_$_value_$_nt_B Tree Node ($attr_ex V) ->
   is_bool V.
skip.
Theorem $access_$_env_out_$_nt_C__is : forall Tree Node CL V,
   $wpd_nt_C Tree ($ntr_nt_C Node CL) ->
   $access_$_env_out_$_nt_C Tree Node ($attr_ex V) ->
   is_list (is_pair (is_string) (is_integer)) V.
skip.
Theorem $local_access_$_$prod_while_$_subWhile_$_nt_C__is : forall Tree Node CL VTr VNode,
   $wpd_nt_C Tree ($ntr_nt_C Node CL) ->
   $local_access_$_$prod_while_$_subWhile_$_nt_C Tree Node ($attr_ex ($pair_c VTr VNode)) ->
   $wpd_nt_C VTr VNode.
skip.


Theorem $env__nt_A__$prod_plus : forall A1 A Node TreeName T,
   $structure_eq__nt_A T ($prod_plus A1 A) ->
   $env__nt_A TreeName T Node ->
   $env__nt_A__host TreeName ($prod_plus A1 A) Node.
skip.
Theorem $value__nt_A__$prod_plus : forall A1 A Node TreeName T,
   $structure_eq__nt_A T ($prod_plus A1 A) ->
   $value__nt_A TreeName T Node ->
   $value__nt_A__host TreeName ($prod_plus A1 A) Node.
skip.
Theorem $env__nt_A__$prod_num : forall N Node TreeName T,
   $structure_eq__nt_A T ($prod_num N) ->
   $env__nt_A TreeName T Node ->
   $env__nt_A__host TreeName ($prod_num N) Node.
skip.
Theorem $value__nt_A__$prod_num : forall N Node TreeName T,
   $structure_eq__nt_A T ($prod_num N) ->
   $value__nt_A TreeName T Node ->
   $value__nt_A__host TreeName ($prod_num N) Node.
skip.
Theorem $env__nt_A__$prod_name : forall L Node TreeName T,
   $structure_eq__nt_A T ($prod_name L) ->
   $env__nt_A TreeName T Node ->
   $env__nt_A__host TreeName ($prod_name L) Node.
skip.
Theorem $value__nt_A__$prod_name : forall L Node TreeName T,
   $structure_eq__nt_A T ($prod_name L) ->
   $value__nt_A TreeName T Node ->
   $value__nt_A__host TreeName ($prod_name L) Node.
skip.
Theorem $env__nt_B__$prod_greater : forall A1 A Node TreeName T,
   $structure_eq__nt_B T ($prod_greater A1 A) ->
   $env__nt_B TreeName T Node ->
   $env__nt_B__host TreeName ($prod_greater A1 A) Node.
skip.
Theorem $value__nt_B__$prod_greater : forall A1 A Node TreeName T,
   $structure_eq__nt_B T ($prod_greater A1 A) ->
   $value__nt_B TreeName T Node ->
   $value__nt_B__host TreeName ($prod_greater A1 A) Node.
skip.
Theorem $env__nt_B__$prod_equal : forall A1 A Node TreeName T,
   $structure_eq__nt_B T ($prod_equal A1 A) ->
   $env__nt_B TreeName T Node ->
   $env__nt_B__host TreeName ($prod_equal A1 A) Node.
skip.
Theorem $value__nt_B__$prod_equal : forall A1 A Node TreeName T,
   $structure_eq__nt_B T ($prod_equal A1 A) ->
   $value__nt_B TreeName T Node ->
   $value__nt_B__host TreeName ($prod_equal A1 A) Node.
skip.
Theorem $env__nt_B__$prod_and : forall B1 B Node TreeName T,
   $structure_eq__nt_B T ($prod_and B1 B) ->
   $env__nt_B TreeName T Node ->
   $env__nt_B__host TreeName ($prod_and B1 B) Node.
skip.
Theorem $value__nt_B__$prod_and : forall B1 B Node TreeName T,
   $structure_eq__nt_B T ($prod_and B1 B) ->
   $value__nt_B TreeName T Node ->
   $value__nt_B__host TreeName ($prod_and B1 B) Node.
skip.
Theorem $env__nt_B__$prod_or : forall B1 B Node TreeName T,
   $structure_eq__nt_B T ($prod_or B1 B) ->
   $env__nt_B TreeName T Node ->
   $env__nt_B__host TreeName ($prod_or B1 B) Node.
skip.
Theorem $value__nt_B__$prod_or : forall B1 B Node TreeName T,
   $structure_eq__nt_B T ($prod_or B1 B) ->
   $value__nt_B TreeName T Node ->
   $value__nt_B__host TreeName ($prod_or B1 B) Node.
skip.
Theorem $env__nt_B__$prod_bTrue : forall  Node TreeName T,
   $structure_eq__nt_B T ($prod_bTrue ) ->
   $env__nt_B TreeName T Node ->
   $env__nt_B__host TreeName ($prod_bTrue ) Node.
skip.
Theorem $value__nt_B__$prod_bTrue : forall  Node TreeName T,
   $structure_eq__nt_B T ($prod_bTrue ) ->
   $value__nt_B TreeName T Node ->
   $value__nt_B__host TreeName ($prod_bTrue ) Node.
skip.
Theorem $env__nt_B__$prod_bFalse : forall  Node TreeName T,
   $structure_eq__nt_B T ($prod_bFalse ) ->
   $env__nt_B TreeName T Node ->
   $env__nt_B__host TreeName ($prod_bFalse ) Node.
skip.
Theorem $value__nt_B__$prod_bFalse : forall  Node TreeName T,
   $structure_eq__nt_B T ($prod_bFalse ) ->
   $value__nt_B TreeName T Node ->
   $value__nt_B__host TreeName ($prod_bFalse ) Node.
skip.
Theorem $env__nt_C__$prod_noop : forall  Node TreeName T,
   $structure_eq__nt_C T ($prod_noop ) ->
   $env__nt_C TreeName T Node ->
   $env__nt_C__host TreeName ($prod_noop ) Node.
skip.
Theorem $env_out__nt_C__$prod_noop : forall  Node TreeName T,
   $structure_eq__nt_C T ($prod_noop ) ->
   $env_out__nt_C TreeName T Node ->
   $env_out__nt_C__host TreeName ($prod_noop ) Node.
skip.
Theorem $env__nt_C__$prod_seq : forall C1 C Node TreeName T,
   $structure_eq__nt_C T ($prod_seq C1 C) ->
   $env__nt_C TreeName T Node ->
   $env__nt_C__host TreeName ($prod_seq C1 C) Node.
skip.
Theorem $env_out__nt_C__$prod_seq : forall C1 C Node TreeName T,
   $structure_eq__nt_C T ($prod_seq C1 C) ->
   $env_out__nt_C TreeName T Node ->
   $env_out__nt_C__host TreeName ($prod_seq C1 C) Node.
skip.
Theorem $env__nt_C__$prod_assign : forall L A Node TreeName T,
   $structure_eq__nt_C T ($prod_assign L A) ->
   $env__nt_C TreeName T Node ->
   $env__nt_C__host TreeName ($prod_assign L A) Node.
skip.
Theorem $env_out__nt_C__$prod_assign : forall L A Node TreeName T,
   $structure_eq__nt_C T ($prod_assign L A) ->
   $env_out__nt_C TreeName T Node ->
   $env_out__nt_C__host TreeName ($prod_assign L A) Node.
skip.
Theorem $env__nt_C__$prod_ifThenElse : forall B C1 C Node TreeName T,
   $structure_eq__nt_C T ($prod_ifThenElse B C1 C) ->
   $env__nt_C TreeName T Node ->
   $env__nt_C__host TreeName ($prod_ifThenElse B C1 C) Node.
skip.
Theorem $env_out__nt_C__$prod_ifThenElse : forall B C1 C Node TreeName T,
   $structure_eq__nt_C T ($prod_ifThenElse B C1 C) ->
   $env_out__nt_C TreeName T Node ->
   $env_out__nt_C__host TreeName ($prod_ifThenElse B C1 C) Node.
skip.
Theorem $env__nt_C__$prod_while : forall B C Node TreeName T,
   $structure_eq__nt_C T ($prod_while B C) ->
   $env__nt_C TreeName T Node ->
   $env__nt_C__host TreeName ($prod_while B C) Node.
skip.
Theorem $env_out__nt_C__$prod_while : forall B C Node TreeName T,
   $structure_eq__nt_C T ($prod_while B C) ->
   $env_out__nt_C TreeName T Node ->
   $env_out__nt_C__host TreeName ($prod_while B C) Node.
skip.


Theorem $wpd_nt_A__$prod_plus : forall T A1 A NodeTree,
   $structure_eq__nt_A T ($prod_plus A1 A) ->
   $wpd_nt_A T NodeTree ->
   $wpd_nt_A__host ($prod_plus A1 A) NodeTree.
skip.
Theorem $wpd_nt_A__$prod_num : forall T N NodeTree,
   $structure_eq__nt_A T ($prod_num N) ->
   $wpd_nt_A T NodeTree ->
   $wpd_nt_A__host ($prod_num N) NodeTree.
skip.
Theorem $wpd_nt_A__$prod_name : forall T L NodeTree,
   $structure_eq__nt_A T ($prod_name L) ->
   $wpd_nt_A T NodeTree ->
   $wpd_nt_A__host ($prod_name L) NodeTree.
skip.
Theorem $wpd_nt_B__$prod_greater : forall T A1 A NodeTree,
   $structure_eq__nt_B T ($prod_greater A1 A) ->
   $wpd_nt_B T NodeTree ->
   $wpd_nt_B__host ($prod_greater A1 A) NodeTree.
skip.
Theorem $wpd_nt_B__$prod_equal : forall T A1 A NodeTree,
   $structure_eq__nt_B T ($prod_equal A1 A) ->
   $wpd_nt_B T NodeTree ->
   $wpd_nt_B__host ($prod_equal A1 A) NodeTree.
skip.
Theorem $wpd_nt_B__$prod_and : forall T B1 B NodeTree,
   $structure_eq__nt_B T ($prod_and B1 B) ->
   $wpd_nt_B T NodeTree ->
   $wpd_nt_B__host ($prod_and B1 B) NodeTree.
skip.
Theorem $wpd_nt_B__$prod_or : forall T B1 B NodeTree,
   $structure_eq__nt_B T ($prod_or B1 B) ->
   $wpd_nt_B T NodeTree ->
   $wpd_nt_B__host ($prod_or B1 B) NodeTree.
skip.
Theorem $wpd_nt_B__$prod_bTrue : forall T  NodeTree,
   $structure_eq__nt_B T ($prod_bTrue ) ->
   $wpd_nt_B T NodeTree ->
   $wpd_nt_B__host ($prod_bTrue ) NodeTree.
skip.
Theorem $wpd_nt_B__$prod_bFalse : forall T  NodeTree,
   $structure_eq__nt_B T ($prod_bFalse ) ->
   $wpd_nt_B T NodeTree ->
   $wpd_nt_B__host ($prod_bFalse ) NodeTree.
skip.
Theorem $wpd_nt_C__$prod_noop : forall T  NodeTree,
   $structure_eq__nt_C T ($prod_noop ) ->
   $wpd_nt_C T NodeTree ->
   $wpd_nt_C__host ($prod_noop ) NodeTree.
skip.
Theorem $wpd_nt_C__$prod_seq : forall T C1 C NodeTree,
   $structure_eq__nt_C T ($prod_seq C1 C) ->
   $wpd_nt_C T NodeTree ->
   $wpd_nt_C__host ($prod_seq C1 C) NodeTree.
skip.
Theorem $wpd_nt_C__$prod_assign : forall T L A NodeTree,
   $structure_eq__nt_C T ($prod_assign L A) ->
   $wpd_nt_C T NodeTree ->
   $wpd_nt_C__host ($prod_assign L A) NodeTree.
skip.
Theorem $wpd_nt_C__$prod_ifThenElse : forall T B C1 C NodeTree,
   $structure_eq__nt_C T ($prod_ifThenElse B C1 C) ->
   $wpd_nt_C T NodeTree ->
   $wpd_nt_C__host ($prod_ifThenElse B C1 C) NodeTree.
skip.
Theorem $wpd_nt_C__$prod_while : forall T B C NodeTree,
   $structure_eq__nt_C T ($prod_while B C) ->
   $wpd_nt_C T NodeTree ->
   $wpd_nt_C__host ($prod_while B C) NodeTree.
skip.


Theorem $wpd_nt_A__ntr_nt_A : forall Tree NodeTree,
   $wpd_nt_A Tree NodeTree ->
   exists Node ChildList, NodeTree = $ntr_nt_A Node ChildList.
skip.
Theorem $wpd_nt_B__ntr_nt_B : forall Tree NodeTree,
   $wpd_nt_B Tree NodeTree ->
   exists Node ChildList, NodeTree = $ntr_nt_B Node ChildList.
skip.
Theorem $wpd_nt_C__ntr_nt_C : forall Tree NodeTree,
   $wpd_nt_C Tree NodeTree ->
   exists Node ChildList, NodeTree = $ntr_nt_C Node ChildList.
skip.


Theorem $wpd__to__env__nt_A : forall Tree NodeTree,
   $wpd_nt_A Tree NodeTree ->
   $env__nt_A Tree Tree NodeTree.
skip.
Theorem $wpd__to__env__nt_B : forall Tree NodeTree,
   $wpd_nt_B Tree NodeTree ->
   $env__nt_B Tree Tree NodeTree.
skip.
Theorem $wpd__to__env__nt_C : forall Tree NodeTree,
   $wpd_nt_C Tree NodeTree ->
   $env__nt_C Tree Tree NodeTree.
skip.
Theorem $wpd__to__value__nt_A : forall Tree NodeTree,
   $wpd_nt_A Tree NodeTree ->
   $value__nt_A Tree Tree NodeTree.
skip.
Theorem $wpd__to__value__nt_B : forall Tree NodeTree,
   $wpd_nt_B Tree NodeTree ->
   $value__nt_B Tree Tree NodeTree.
skip.
Theorem $wpd__to__env_out__nt_C : forall Tree NodeTree,
   $wpd_nt_C Tree NodeTree ->
   $env_out__nt_C Tree Tree NodeTree.
skip.
Theorem $wpd__to__while_local_subWhile__nt_C : forall Tree Tree' NodeTree,
   $structure_eq__nt_C Tree Tree' ->
   $wpd_nt_C Tree NodeTree ->
   $while_local_subWhile Tree Tree' NodeTree.
skip.


Theorem $structure_eq__nt_A__equal : forall T1 T2,
   $structure_eq__nt_A T1 T2 -> T1 = T2.
skip.
Theorem $structure_eq__nt_A__symm : forall T1 T2,
   $structure_eq__nt_A T1 T2 ->
   $structure_eq__nt_A T2 T1.
skip.
Theorem $structure_eq__nt_A__wpd : forall T NTr,
   $wpd_nt_A T NTr -> $structure_eq__nt_A T T.
skip.
Theorem $structure_eq__nt_A__host__expand : forall T1 T2,
   $structure_eq__nt_A__host T1 T2 ->
   $structure_eq__nt_A T1 T2.
skip.
Theorem $structure_eq__nt_B__equal : forall T1 T2,
   $structure_eq__nt_B T1 T2 -> T1 = T2.
skip.
Theorem $structure_eq__nt_B__symm : forall T1 T2,
   $structure_eq__nt_B T1 T2 ->
   $structure_eq__nt_B T2 T1.
skip.
Theorem $structure_eq__nt_B__wpd : forall T NTr,
   $wpd_nt_B T NTr -> $structure_eq__nt_B T T.
skip.
Theorem $structure_eq__nt_B__host__expand : forall T1 T2,
   $structure_eq__nt_B__host T1 T2 ->
   $structure_eq__nt_B T1 T2.
skip.
Theorem $structure_eq__nt_C__equal : forall T1 T2,
   $structure_eq__nt_C T1 T2 -> T1 = T2.
skip.
Theorem $structure_eq__nt_C__symm : forall T1 T2,
   $structure_eq__nt_C T1 T2 ->
   $structure_eq__nt_C T2 T1.
skip.
Theorem $structure_eq__nt_C__wpd : forall T NTr,
   $wpd_nt_C T NTr -> $structure_eq__nt_C T T.
skip.
Theorem $structure_eq__nt_C__host__expand : forall T1 T2,
   $structure_eq__nt_C__host T1 T2 ->
   $structure_eq__nt_C T1 T2.
skip.


Theorem $structure_eq__$prod_plus : forall T A1 A,
   $structure_eq__nt_A T ($prod_plus A1 A) -> 
   $structure_eq__nt_A__host T ($prod_plus A1 A).
skip.
Theorem $structure_eq__$prod_num : forall T N,
   $structure_eq__nt_A T ($prod_num N) -> 
   $structure_eq__nt_A__host T ($prod_num N).
skip.
Theorem $structure_eq__$prod_name : forall T L,
   $structure_eq__nt_A T ($prod_name L) -> 
   $structure_eq__nt_A__host T ($prod_name L).
skip.
Theorem $structure_eq__$prod_greater : forall T A1 A,
   $structure_eq__nt_B T ($prod_greater A1 A) -> 
   $structure_eq__nt_B__host T ($prod_greater A1 A).
skip.
Theorem $structure_eq__$prod_equal : forall T A1 A,
   $structure_eq__nt_B T ($prod_equal A1 A) -> 
   $structure_eq__nt_B__host T ($prod_equal A1 A).
skip.
Theorem $structure_eq__$prod_and : forall T B1 B,
   $structure_eq__nt_B T ($prod_and B1 B) -> 
   $structure_eq__nt_B__host T ($prod_and B1 B).
skip.
Theorem $structure_eq__$prod_or : forall T B1 B,
   $structure_eq__nt_B T ($prod_or B1 B) -> 
   $structure_eq__nt_B__host T ($prod_or B1 B).
skip.
Theorem $structure_eq__$prod_bTrue : forall T ,
   $structure_eq__nt_B T ($prod_bTrue ) -> 
   $structure_eq__nt_B__host T ($prod_bTrue ).
skip.
Theorem $structure_eq__$prod_bFalse : forall T ,
   $structure_eq__nt_B T ($prod_bFalse ) -> 
   $structure_eq__nt_B__host T ($prod_bFalse ).
skip.
Theorem $structure_eq__$prod_noop : forall T ,
   $structure_eq__nt_C T ($prod_noop ) -> 
   $structure_eq__nt_C__host T ($prod_noop ).
skip.
Theorem $structure_eq__$prod_seq : forall T C1 C,
   $structure_eq__nt_C T ($prod_seq C1 C) -> 
   $structure_eq__nt_C__host T ($prod_seq C1 C).
skip.
Theorem $structure_eq__$prod_assign : forall T L A,
   $structure_eq__nt_C T ($prod_assign L A) -> 
   $structure_eq__nt_C__host T ($prod_assign L A).
skip.
Theorem $structure_eq__$prod_ifThenElse : forall T B C1 C,
   $structure_eq__nt_C T ($prod_ifThenElse B C1 C) -> 
   $structure_eq__nt_C__host T ($prod_ifThenElse B C1 C).
skip.
Theorem $structure_eq__$prod_while : forall T B C,
   $structure_eq__nt_C T ($prod_while B C) -> 
   $structure_eq__nt_C__host T ($prod_while B C).
skip.

